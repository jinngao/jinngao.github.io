<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Synchronized之对象锁]]></title>
    <url>%2F2019%2F01%2F02%2FSynchronized%E4%B9%8B%E5%AF%B9%E8%B1%A1%E9%94%81%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[初识Synchronized]]></title>
    <url>%2F2019%2F01%2F02%2F%E5%88%9D%E8%AF%86Synchronized%2F</url>
    <content type="text"><![CDATA[Synchronized作用对于Synchronized，想必大多数的同学们都很熟悉。简单的说，Synchronized主要作用是保证同一段代码在同一时刻保证最多只有一个线程访问。通过使用Synchronized，让我们在处理多线程并发时不会出现问题。那么假如不使用任何并发方法，多线程访问同一段代码会出现什么问题呢？让我们来看一段示例代码。 示例代码示例代码中通过两个线程，每个线程同时执行i++ 10W次。然后我们看执行完结果是不是预想的20W次。 12345678910111213141516171819202122public class SynchronizedDemo1 implements Runnable &#123; static SynchronizedDemo1 synchronizedDemo1 = new SynchronizedDemo1(); static int i = 0; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(synchronizedDemo1); Thread t2 = new Thread(synchronizedDemo1); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); &#125; @Override public void run() &#123; for (int j=0;j&lt;100000;j++)&#123; i++; &#125; &#125;&#125; 第一次执行，结果为125187 第二次执行，结果为120759 第三次执行，结果为147030 从上面的执行结果来看，可以得出不使用并发时段，多个线程同时访问同一段代码会出现问题，无法保证线程安全。 总结那么我们可以得出一个结论，使用Synchronized可以保证线程安全。然后Synchronized是如何保证多个线程同一时刻访问代码最多只有一个线程访问呢？下一篇我们继续研究。]]></content>
      <categories>
        <category>并发系列</category>
      </categories>
      <tags>
        <tag>Synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你知道HTTP和HTTPS吗]]></title>
    <url>%2F2018%2F12%2F30%2F%E4%BD%A0%E7%9F%A5%E9%81%93HTTP%E5%92%8CHTTPS%E5%90%97%2F</url>
    <content type="text"><![CDATA[前言现在大多数网站都已经是用了HTTPS，这是为什么呢？今天我们来学习一下HTTP和HTTPS的区别。 HTTP为什么不安全呢？请求或相应过程中，数据容易被篡改当我们发起一个HTTP请求时，会从客户端发送一个请求报文到服务器。然后在请求报文发送到服务器这个传输过程中，会经过许多节点。节点也就是转发者，这个传输 过程需要通过一个个节点来一步步的发送到服务器。具体如下图 通过上图，可以看出正常的HTTP请求从客户端经过中间节点的转发，最后将请求报文传输到服务器。但是在传输过程中某个节点可以拦截请求报文，并篡改数据。当节点2拦截并篡改了请求报文，将请求报文1改成了请求报文2，如下图 可以看出节点1传输到节点2时，数据还是请求报文1。但是当节点2拦截并篡改了请求报文1，传输过程中变为了请求报文2，最后服务器接收到的是请求报文2，而不是刚开始的请求报文1。 明文传输明文传输也就是说HTTP传输数据不存在加密的说法，不对数据进行加密就直接传输，因此可能被拦截者修改数据。 HTTPS为什么是安全的呢？HTTPS是什么 呢HTTPS是超文本传输安全协议，是一种通过计算机网络进行安全通信的传输协议。简单点说HTTPS就是对HTTP进行了升级，使数据传输更加安全。 HTTPS如何保证安全呢？加密对于加密，想必好多同学都知道。而且还能流畅的说出加密的俩种方式，非对称加密和对称加密。一般我们都会使用对称加密来传输数据，直接使用非对称加密的话，它的解密速度较慢，性能开销较大。那么我们使用加密后，怎么解密呢？这时候就需要密钥了，而且我们需要将密钥一起和数据传输给服务器。 那么就有一个问题了，我们怎么能保证密钥不被别人截取呢？我们需要使用非对称加密，整个传输过程可以分为以下几步。 客户端向服务器请求HTTPS连接 服务器向客户端传输公钥 客户端解析公钥，验证是否有效，若有效则产生一个随机值，并用公钥进行加密 客户端将加密后的随机值传输给服务器，实际上这个随机值 也就是私钥。 服务器通过私钥对传输内容进行加密 客户端通过私钥解析服务器传输过来的加密内容 总结这样HTTPS通过加密就解决了HTTP的不安全问题，想要详细了解HTTPS的工作原理的同学可以期待下一篇哦。]]></content>
      <categories>
        <category>网络系列</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新认识RxJava系列之订阅流程源码分析]]></title>
    <url>%2F2018%2F12%2F30%2F%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86RxJava%E7%B3%BB%E5%88%97%E4%B9%8B%E8%AE%A2%E9%98%85%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言学习RxJava，我们不光要知道它如何使用，还要理解它的原理。只有这样，我们才能不断的成长，早日成为大佬。 基本订阅流程常用代码123456789101112131415161718192021222324252627Observable .create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(&quot;1&quot;); emitter.onNext(&quot;2&quot;); emitter.onNext(&quot;3&quot;); emitter.onComplete(); &#125; &#125;) .subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(String s) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;); 上面的代码就是我们一般实现订阅的基本代码了，然后我们一步步的来分析源码实现。 创建被观察者1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, &quot;source is null&quot;); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; 可以看到最后调用了RxJavaPlugins.onAssembly方法，并且传入了一个ObservableCreate对象。 onAssembly()1234567public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source; &#125; 从上面的方法中可以看到最后返回的是传入的source对象，也就是ObservableCreate对象，那么ObservableCreate是什么呢? 1234567891011121314151617public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123;//省略... @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); // observer.onSubscribe(parent); try &#123; //发送事件 source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125; &#125; &#125; 可以看出ObservableCreate继承了Observable，然后subscribeActual内部实现大概分为以下三步。 创建CreateEmitter 调用onSubscribe() 调用subscribe()发送事件 CreateEmitter从源码中可以看出将observer传递给了CreateEmitter对象，然后又将CreateEmitter对象传递给了onSubscribe方法。首先来看一下CreateEmitter源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465static final class CreateEmitter&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements ObservableEmitter&lt;T&gt;, Disposable &#123; private static final long serialVersionUID = -3434801548987643227L; final Observer&lt;? super T&gt; observer; CreateEmitter(Observer&lt;? super T&gt; observer) &#123; this.observer = observer; &#125; @Override public void onNext(T t) &#123; if (t == null) &#123; onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;)); return; &#125; if (!isDisposed()) &#123; observer.onNext(t); &#125; &#125; @Override public void onError(Throwable t) &#123; if (!tryOnError(t)) &#123; RxJavaPlugins.onError(t); &#125; &#125; @Override public void onComplete() &#123; if (!isDisposed()) &#123; try &#123; observer.onComplete(); &#125; finally &#123; dispose(); &#125; &#125; &#125; @Override public void setDisposable(Disposable d) &#123; DisposableHelper.set(this, d); &#125; @Override public void setCancellable(Cancellable c) &#123; setDisposable(new CancellableDisposable(c)); &#125; @Override public ObservableEmitter&lt;T&gt; serialize() &#123; return new SerializedEmitter&lt;T&gt;(this); &#125; @Override public void dispose() &#123; DisposableHelper.dispose(this); &#125; @Override public boolean isDisposed() &#123; return DisposableHelper.isDisposed(get()); &#125; &#125; 可以看出在onNext方法和onComplete方法中分别对是否处于Disposed状态进行了判断处理。然后通过查看源码知道了CreateEmitter实现了ObservableEmitter接口，看一下CreateEmitter的onNext方法。 1234567@Override public void onNext(T t) &#123; //...... if (!isDisposed()) &#123; observer.onNext(t); &#125; &#125; 可以看出当不处于Disposed状态时，将会调用observer的onNext方法，也就是我们常见的onNext方法。 1234@Override public void onNext(String s) &#123; //作出响应动作 &#125; observer.onSubscribe()调用观察者的onSubscribe()，也就是我们在创建观察者时复写的onSubscribe()。该方法是发生下被观察者发送事件之前的，部分代码如下： 123456.subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; //..... source.subscribe()这里的source对象，也就是我们最开始传入的参数ObservableOnSubscribe。也就是复写被观察者的subscribe方法，部分代码如下 12345678@Overridepublic void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(&quot;1&quot;); emitter.onNext(&quot;2&quot;); emitter.onNext(&quot;3&quot;); emitter.onComplete(); &#125; &#125;) 订阅12345public final void subscribe(Observer&lt;? super T&gt; observer) &#123; //...... subscribeActual(observer); //...... &#125; 上面代码是订阅过程比较重要的代码，我们继续向下看。 1protected abstract void subscribeActual(Observer&lt;? super T&gt; observer); 可以看出Observable的subscribeActual方法是一个抽象方法，那么我们来看一下是谁实现了它。还记得上面我们分析过ObservableCreate继承了Observable，也就是说ObservableCreate是Observable的子类。那么只要看ObservableCreate的subscribeActual方法就可以了，在上面我们已经分析过了，可以回去再看一下。 总结]]></content>
      <categories>
        <category>RxJava系列</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新认识RxJava系列之基本使用]]></title>
    <url>%2F2018%2F12%2F30%2F%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86RxJava%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言依稀记得第一次接触RxJava时，对着文档撸了一遍。仍然是懵懵的，为啥呢？当然是因为菜，哈哈。现在重新来学习下RxJava，重新认识它究竟有什么样的魅力。对于RxJava 1.xx版本和RxJava 2.xx版本，本质上没有什么区别，只是RxJava 2.xx版本增加了新特性。所以，我们直接来学习RxJava 2.xx版本，本系列主要分为以下几部分。 RxJava 2.xx版本基本使用 RxJava 2.xx版本源码分析 RxJava 2.xx版本实战 基本使用优点 代码逻辑简洁 实现优雅 使用方便 代码逻辑简洁看到这个优点，想必同学们心里有数了。可以想象下我们项目的代码特别特别多，看着就头疼。但是使用RxJava时，代码逻辑会变得简洁，方便我们阅读代码。 实现优雅这个优点，我觉得就是俩字，牛逼。让人一看，就觉得代码风格特别高大上。 组成 被观察者(Observable)，产生事件 观察者(Observer)，接受事件并作出响应 订阅(Subscribe)，连接被观察者和观察者 创建被观察者create()123456789Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onComplete(); &#125; &#125;); 上面代码就是创建Observable的基本方式，通过create方法来创建。那么我们来看一下方法内的几个参数 ObservableOnSubscribe123456789public interface ObservableOnSubscribe&lt;T&gt; &#123; /** * Called for each Observer that subscribes. * @param e the safe emitter instance, never null * @throws Exception on error */ void subscribe(ObservableEmitter&lt;T&gt; e) throws Exception;&#125; 从源码中可以看出ObservableOnSubscribe是一个接口，里面有一个subscribe方法，也就是我们创建Observable实现的方法。 ObservableEmitter12345678910public interface ObservableEmitter&lt;T&gt; extends Emitter&lt;T&gt; &#123; void setDisposable(Disposable d); void setCancellable(Cancellable c); boolean isDisposed(); ObservableEmitter&lt;T&gt; serialize();&#125; 可以看出ObservableEmitter也是一个接口，并且继承了Emitter，然后我们来看一下Emitter。 1234567public interface Emitter&lt;T&gt; &#123; void onNext(@NonNull T value); void onError(@NonNull Throwable error); void onComplete(); 从Emitter中就可以看到熟悉的方法了，这三个方法就是我们常用的发送事件相关的方法。 onNext()发送该事件时，观察者会回调该方法。简单点，就是用来发送事件 onError()发送该事件后，其他事件不再发送。通过方法名字，也知道该方法表示发生错误 onComplete()发送该事件后，其他事件不再发送。与onError()不同的是， onComplete()表示所有的事件都发送完毕，然后事件不再发送。 subscribe方法主要是通过ObservableEmitter来产生事件，并通知Observer。 ##Observable.just() 1Observable observable = Observable.just(1,2,3); just()表示创建被观察者，并发送事件。比如上面的代码中通过just方法创建了一个Observable，并且发送了三个事件。效果相当于以下代码 1234e.onNext(1);e.onNext(2);e.onNext(3);e.onComplete(); 需要注意的是，just方法发送的事件不能超过10个，在使用时，同学们需要特备注意哦。 ##Observable.fromArray() 12Integer[] integers = &#123;1,2,3&#125;;Observable observable = Observable.fromArray(integers); 可以看出与just方法不同的是，fromArray方法可以传入一个数组，并且传入多于10个以上的参数。然后实现效果也是创建被观察者并发送相应的事件，与just方法类似。 创建观察者创建观察者有以下2种方式，我们来看一下。 实现Observer接口123456789101112131415161718192021Observer&lt;Integer&gt; observer = new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; //最先调用onSubscribe &#125; @Override public void onNext(Integer integer) &#123; //对onNext事件响应 &#125; @Override public void onError(Throwable e) &#123; //对onError事件响应 &#125; @Override public void onComplete() &#123; //onComplete事件响应 &#125; &#125;; 通过实现Observer接口来创建观察者，从上面的代码可以看到比较熟悉的几个方法。对于onSubscribe方法，它是最先调用的，其他三个方法都是对事件作出响应。 Subscriber123456789101112131415161718192021Subscriber&lt;Integer&gt; subscriber = new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; //最先调用onSubscribe &#125; @Override public void onNext(Integer integer) &#123; //对onNext事件响应 &#125; @Override public void onError(Throwable t) &#123; //对onError事件响应 &#125; @Override public void onComplete() &#123; //onComplete事件响应 &#125; &#125;; 可以看出通过Subscriber和Observer创建观察者是差不多的。 订阅1observable.subscribe(observer); 调用subscribe方法就可以将被观察者和观察者订阅在一起了，当被观察者发送事件时，观察者就会作出响应。 总结大概分析了下RxJava 2.xx版本的使用流程，了解了如何创建被观察者、观察者以及订阅。]]></content>
      <categories>
        <category>RxJava系列</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp源码流程分析]]></title>
    <url>%2F2018%2F12%2F24%2FOkHttp%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言今天我们将来分析OkHttp的执行流程，从源码中来学习OkHttp的设计思想。 基本流程使用OkHttp主要分为三步，想必同学们都比较熟悉了，如下： 创建OkHttpClient 创建Request 创建Call 那么我们主要来分析OkHttpClient和Call的源码执行了流程，至于Request，有兴趣的同学可以自行查看源码。 OkHttpClient首先我们来看一下OkHttpClient的构造方法，如下 123public OkHttpClient() &#123; this(new Builder()); &#125; 当我们直接new OkHttpClient时，会调用默认的构造方法。在构造方法中我们可以看到new 了一个Builder类，然后我们来看一下这个Builder类。 1234567891011121314151617public static final class Builder &#123; Dispatcher dispatcher; @Nullable Proxy proxy; List&lt;Protocol&gt; protocols; List&lt;ConnectionSpec&gt; connectionSpecs; //...... Dns dns; boolean followSslRedirects; boolean followRedirects; boolean retryOnConnectionFailure; int callTimeout; int connectTimeout; int readTimeout; int writeTimeout; int pingInterval; //...... &#125; Builder类代码比较多，可以看出OkHttpClient使用了建造者模式，我们主要来看Dispatcher、connectTimeout、readTimeout以及writeTimeout这几个属性。 Dispatcher 表示分发器，在OkHttpClient的同步和异步中会通过它来调用相关的方法 connectTimeout 表示连接超时 readTimeout 表示读取超时 writeTimeout 表示写入超时 因为我们一般都是使用OkHttpClient时，都是会直接new。这样的话上面三个超时时间都是采用的默认值，当然我们可以自己设置超时时间，代码如下 12345OkHttpClient okHttpClient = new OkHttpClient.Builder() .connectTimeout(20,TimeUnit.SECONDS) .readTimeout(20,TimeUnit.SECONDS) .writeTimeout(20,TimeUnit.SECONDS) .build(); Call创建Call对象，主要调用了OkHttpClient的newCall方法。 123@Override public Call newCall(Request request) &#123; return RealCall.newRealCall(this, request, false /* for web socket */); &#125; 可以看出，实际上是调用了RealCall.newRealCall方法。那么我们继续往下分析 123456static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; // Safely publish the Call instance to the EventListener. RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call; &#125; 从源码中可以看出newRealCall方法实际上是返回了一个RealCall对象，那么也就是OkHttpClient的newCall方法返回的是RealCall对象，接下来我们来看同步流程。 同步从上面我们分析出OkHttpClient的newCall方法返回的是RealCall对象，所以同步流程也就是调用了RealCall对象的execute方法。 123456789101112131415161718192021222324@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); timeout.enter(); eventListener.callStart(this); try &#123; //1. client.dispatcher().executed(this); //2. Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; &#125; catch (IOException e) &#123; e = timeoutExit(e); eventListener.callFailed(this, e); throw e; &#125; finally &#123; //3. client.dispatcher().finished(this); &#125; &#125; 同步流程可以分为三步，也就是上面源码中的注释1到注释3。 注释1首先看一下client.dispatcher().executed(this)方法源码 123synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call); &#125; runningSyncCalls表示同步调用，那么我们可以理解注释1为通知Dispatcher分发器执行同步流程。 注释21234567891011121314151617181920Response getResponseWithInterceptorChain() throws IOException &#123; // 创建拦截器集合 List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); // 添加一系列的拦截器 interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); // 创建了一个拦截器链 Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); // 调用拦截器链的proceed方法 return chain.proceed(originalRequest); &#125; 从源码中可以看出，getResponseWithInterceptorChain方法主要有以下步骤。 创建拦截器集合 添加一系列的拦截器 创建了一个拦截器链 调用拦截器链的proceed方法 我们主要来分析下拦截器链的proceed方法，源码如下 12345678910111213public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; // ...... // 创建下一个拦截器对应的RealInterceptorChain RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); // 获取当前的拦截器 Interceptor interceptor = interceptors.get(index); //将下一个拦截器的RealInterceptorChain对象传递下去 Response response = interceptor.intercept(next); // ...... &#125; 这个proceed方法，我们可以理解为拦截器链的工作模式。我们来分析下拦截器链是如何工作的？可以理解为拦截器链中的多个拦截器，从第一个拦截器开始进行相关拦截操作。操作完成后将下一个拦截器的RealInterceptorChain对象传递给第二个拦截器，然后依次进行下去，直到拦截器链中的最后一个拦截器执行完相关拦截操作。 异步其实异步和同步最终执行的方法都是getResponseWithInterceptorChain方法，区别异步流程中通过线程池执行Runnable来执行getResponseWithInterceptorChain方法。 123456789@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback)); &#125; 从源码中可以看出最终传入了AsyncCall对象，然后我们继续分析 123456void enqueue(AsyncCall call) &#123; synchronized (this) &#123; readyAsyncCalls.add(call); &#125; promoteAndExecute(); &#125; 调用了 promoteAndExecute()，继续看 12345678910private boolean promoteAndExecute() &#123; //...... for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123; AsyncCall asyncCall = executableCalls.get(i); asyncCall.executeOn(executorService()); &#125; return isRunning; &#125; 调用了asyncCall.executeOn方法 1234567891011121314151617void executeOn(ExecutorService executorService) &#123; assert (!Thread.holdsLock(client.dispatcher())); boolean success = false; try &#123; executorService.execute(this); success = true; &#125; catch (RejectedExecutionException e) &#123; InterruptedIOException ioException = new InterruptedIOException(&quot;executor rejected&quot;); ioException.initCause(e); eventListener.callFailed(RealCall.this, ioException); responseCallback.onFailure(RealCall.this, ioException); &#125; finally &#123; if (!success) &#123; client.dispatcher().finished(this); // This call is no longer running! &#125; &#125; &#125; 最后还是调用了execute方法，接下来就跟同步流程一样，调用了getResponseWithInterceptorChain方法。 总结 整个流程看下来，有点体会 。看源码不能心急，需要一步一步的看下去。网上有很多相关的博客，可以先跟博客的思路走一遍，然后自己再把流程看一遍，最后自己画一个流程图。做完这三步，基本上是掌握了，面试的时候也可以理直气壮的跟面试官说OkHttp的源码流程了。]]></content>
      <categories>
        <category>OkHttp系列</category>
      </categories>
      <tags>
        <tag>OkHttp源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter系列之HelloFlutter]]></title>
    <url>%2F2018%2F12%2F21%2FFlutter%E7%B3%BB%E5%88%97%E4%B9%8BHelloFlutter%2F</url>
    <content type="text"><![CDATA[前言在上一篇文章中，我们在Windows环境下搭建了Flutter的开发环境，并且通过AS成功运行了Flutter的示例Demo。今天我们来动手实现自己的第一个Flutter项目，HelloFlutter。 新建HelloFlutter通过AS，我们可以新建一个Flutter项目，如下图 接下来我们填写项目的基本信息就好了，然后等待项目新建完成后，我们会看到AS已经为我们生成了默认的代码。因为我们需要学习如何创建属于自己的Flutter项目，所以将main.dart文件中的所有代码删除。 新建main函数现在我们首先创建一个main函数，主要代码是运行在main函数中的，如下图 1234//第一种写法void main ()&#123; runApp(MyApp());&#125; 12//第二种以下写法，仅限于函数体只有一行代码void main() =&gt; runApp(MyApp()); 在代码中我们可以看出main函数有俩种写法，第一种是比较常规的写法，而第二种写法仅限于函数体中只有一行代码，否则不可以。 MyApp通过对Flutter了解，我们可以知道在Flutter中，有许多Widget。Widget主要分为俩种，一种是StatelessWidget，表示不可变状态窗口组件，也就是说它是不可以改变的，比如文字。另外一种是StatefulWidget，表示可变状态窗口组件，比如进度条。那么我们需要在项目中显示文字HelloFlutter，就需要StatelessWidget，然后我们创建MyAPP，并继承StatelessWidget。 1234567class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return null; &#125;&#125; 当我们继承了StatelessWidget时，AS会提示我们需要创建build方法。从上面代码中可以看出build方法默认返回null。然后我们来实现一个material风格的app，代码如下 12345678910111213141516171819@override Widget build(BuildContext context) &#123; // TODO: implement build return MaterialApp( //表示最近列表中APP名字 title: (&apos;Hello Flutter Demo&apos;), home: Scaffold( //表示APP标题 appBar: AppBar( title: Text(&apos;Flutter Demo&apos;), ), //Center表示居中 body: Center( //表示Text child: Text(&apos;Hello Flutter&apos;), ), ), ); &#125; 通过代码中的注释，我们大概可以看懂上面的属性代表什么意思。然后我们运行APP，就可以在设备上看到Hello Flutter界面了。 总结建议同学们多写几次Hello Flutter项目，多了解下上面出现过得属性。]]></content>
      <categories>
        <category>Flutter系列</category>
      </categories>
      <tags>
        <tag>HelloFlutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter之Windows开发环境搭建]]></title>
    <url>%2F2018%2F12%2F20%2FFlutter%E7%B3%BB%E5%88%97%E4%B9%8BWindows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言RN出现时，没有去详细的学习。现在Flutter正式版出来了，好好的研究下。本文主要介绍在Windows环境下，搭建Flutter的各种坑。 开发环境 Windows 10 Android Studio 3.2.1 一加 5T 下载Flutter源码主要参照Flutter官方文档，下载Flutter源码，如下： 1git clone -b beta https://github.com/flutter/flutter.git 配置环境变量下载成功后，为了以后方便使用，将Flutter根目录下bin路径添加到PATH环境变量中。 国内镜像设置由于有些同学们不能科学上网的原因，我们需要设置国内镜像。根据官方文档推荐，需要添加PUB_HOSTED_URL和FLUTTER_STORAGE_BASE_URL两个环境变量，具体值如下 12PUB_HOSTED_URL=https://pub.flutter-io.cnFLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 运行Flutter安装程序在Flutter根目录中，同学们找到flutter_console.bat。然后双击运行，就会出现Flutter控制台，然后我们执行flutter doctor，等待一段时间后，Flutter会出现安装结果。 AS中安装Flutter插件 安装Flutter插件后会自动安装Dart插件，然后设置Flutter和Dart二者SDK路径，如下 运行Flutter Demo经过上面的安装步骤，想必同学们已经安装成功了。那么接下来我们就是要运行Flutter Demo了，如下 在Flutter根目录的examples中有几个Flutter Demo，我们在flutter_gallery根目录中运行“flutter run”命令，就可以运行在手机中了。 或者通过Android Studio打开flutter_gallery ，然后直接运行程序。 问题Waiting for another flutter command to release the startup lock…解决方法如下： 打开任务管理器，结束所有的dart.exe 如果开启了代理，关闭代理 重启AS Unable to find git in your PATH出现这个错误，需要我们正确的设置Git环境变量。我们将git的bin路径添加到环境变量中。 总结在Windows环境下配置Flutter还是有比较多坑的，遇到问题一个一个的解决。能够科学上网的同学尽量在Google上搜索问题的解决方法，可以解决大部分问题。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FragmentPagerAdapter和FragmentStatePagerAdapter区别]]></title>
    <url>%2F2018%2F12%2F09%2FFragmentPagerAdapter%E5%92%8CFragmentStatePagerAdapter%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言“变强，从现在开始变为我心中的执念。” StrongPlan计划，也就是变强计划，从现在开始。经历过裁员风波，认识到了自己严重的不足。有句老话说得好，打铁还需自身硬！ FragmentPagerAdapter首先我们来看一下FragmentPagerAdapter的destroyItem方法源码 1234567public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123; if (this.mCurTransaction == null) &#123; this.mCurTransaction = this.mFragmentManager.beginTransaction(); &#125; this.mCurTransaction.detach((Fragment)object); &#125; 方法最后调用了detach方法，将Fragment的View销毁，而Fragment对象还存在。FragmentPagerAdapter会将每一个生成的Fragment保存在内存中，所以只适用于页面较少的情况。如果页面比较多，内存占用较大，用户体验会不好。 FragmentStatePagerAdapter我们还是看一下FragmentStatePagerAdapter的destroyItem方法，看一是如何处理的。 1234567891011121314public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123; Fragment fragment = (Fragment)object; if (this.mCurTransaction == null) &#123; this.mCurTransaction = this.mFragmentManager.beginTransaction(); &#125; while(this.mSavedState.size() &lt;= position) &#123; this.mSavedState.add((Object)null); &#125; this.mSavedState.set(position, fragment.isAdded() ? this.mFragmentManager.saveFragmentInstanceState(fragment) : null); this.mFragments.set(position, (Object)null); this.mCurTransaction.remove(fragment); &#125; 可以看出跟FragmentPagerAdapter不同的是，最后调用了remove方法。会将Fragment删除并释放资源，也就是说保留当前Fragment，当Fragment离开后，就会被消除，然后释放资源。 总结通过分析，可以得知FragmentPagerAdapter适合页面较少的情况。FragmentStatePagerAdapter适合页面较多，不会占据大量的内存。]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Fragment</tag>
      </tags>
  </entry>
</search>
