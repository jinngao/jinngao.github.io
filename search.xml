<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OkHttp源码流程分析]]></title>
    <url>%2F2018%2F12%2F24%2FOkHttp%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言今天我们将来分析OkHttp的执行流程，从源码中来学习OkHttp的设计思想。 基本流程使用OkHttp主要分为三步，想必同学们都比较熟悉了，如下： 创建OkHttpClient 创建Request 创建Call 那么我们主要来分析OkHttpClient和Call的源码执行了流程，至于Request，有兴趣的同学可以自行查看源码。 OkHttpClient首先我们来看一下OkHttpClient的构造方法，如下 123public OkHttpClient() &#123; this(new Builder()); &#125; 当我们直接new OkHttpClient时，会调用默认的构造方法。在构造方法中我们可以看到new 了一个Builder类，然后我们来看一下这个Builder类。 1234567891011121314151617public static final class Builder &#123; Dispatcher dispatcher; @Nullable Proxy proxy; List&lt;Protocol&gt; protocols; List&lt;ConnectionSpec&gt; connectionSpecs; //...... Dns dns; boolean followSslRedirects; boolean followRedirects; boolean retryOnConnectionFailure; int callTimeout; int connectTimeout; int readTimeout; int writeTimeout; int pingInterval; //...... &#125; Builder类代码比较多，可以看出OkHttpClient使用了建造者模式，我们主要来看Dispatcher、connectTimeout、readTimeout以及writeTimeout这几个属性。 Dispatcher 表示分发器，在OkHttpClient的同步和异步中会通过它来调用相关的方法 connectTimeout 表示连接超时 readTimeout 表示读取超时 writeTimeout 表示写入超时 因为我们一般都是使用OkHttpClient时，都是会直接new。这样的话上面三个超时时间都是采用的默认值，当然我们可以自己设置超时时间，代码如下 12345OkHttpClient okHttpClient = new OkHttpClient.Builder() .connectTimeout(20,TimeUnit.SECONDS) .readTimeout(20,TimeUnit.SECONDS) .writeTimeout(20,TimeUnit.SECONDS) .build(); Call创建Call对象，主要调用了OkHttpClient的newCall方法。 123@Override public Call newCall(Request request) &#123; return RealCall.newRealCall(this, request, false /* for web socket */); &#125; 可以看出，实际上是调用了RealCall.newRealCall方法。那么我们继续往下分析 123456static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; // Safely publish the Call instance to the EventListener. RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call; &#125; 从源码中可以看出newRealCall方法实际上是返回了一个RealCall对象，那么也就是OkHttpClient的newCall方法返回的是RealCall对象，接下来我们来看同步流程。 同步从上面我们分析出OkHttpClient的newCall方法返回的是RealCall对象，所以同步流程也就是调用了RealCall对象的execute方法。 123456789101112131415161718192021222324@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); timeout.enter(); eventListener.callStart(this); try &#123; //1. client.dispatcher().executed(this); //2. Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; &#125; catch (IOException e) &#123; e = timeoutExit(e); eventListener.callFailed(this, e); throw e; &#125; finally &#123; //3. client.dispatcher().finished(this); &#125; &#125; 同步流程可以分为三步，也就是上面源码中的注释1到注释3。 注释1首先看一下client.dispatcher().executed(this)方法源码 123synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call); &#125; runningSyncCalls表示同步调用，那么我们可以理解注释1为通知Dispatcher分发器执行同步流程。 注释21234567891011121314151617181920Response getResponseWithInterceptorChain() throws IOException &#123; // 创建拦截器集合 List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); // 添加一系列的拦截器 interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); // 创建了一个拦截器链 Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); // 调用拦截器链的proceed方法 return chain.proceed(originalRequest); &#125; 从源码中可以看出，getResponseWithInterceptorChain方法主要有以下步骤。 创建拦截器集合 添加一系列的拦截器 创建了一个拦截器链 调用拦截器链的proceed方法 我们主要来分析下拦截器链的proceed方法，源码如下 12345678910111213public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; // ...... // 创建下一个拦截器对应的RealInterceptorChain RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); // 获取当前的拦截器 Interceptor interceptor = interceptors.get(index); //将下一个拦截器的RealInterceptorChain对象传递下去 Response response = interceptor.intercept(next); // ...... &#125; 这个proceed方法，我们可以理解为拦截器链的工作模式。我们来分析下拦截器链是如何工作的？可以理解为拦截器链中的多个拦截器，从第一个拦截器开始进行相关拦截操作。操作完成后将下一个拦截器的RealInterceptorChain对象传递给第二个拦截器，然后依次进行下去，直到拦截器链中的最后一个拦截器执行完相关拦截操作。 异步其实异步和同步最终执行的方法都是getResponseWithInterceptorChain方法，区别异步流程中通过线程池执行Runnable来执行getResponseWithInterceptorChain方法。 123456789@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback)); &#125; 从源码中可以看出最终传入了AsyncCall对象，然后我们继续分析 123456void enqueue(AsyncCall call) &#123; synchronized (this) &#123; readyAsyncCalls.add(call); &#125; promoteAndExecute(); &#125; 调用了 promoteAndExecute()，继续看 12345678910private boolean promoteAndExecute() &#123; //...... for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123; AsyncCall asyncCall = executableCalls.get(i); asyncCall.executeOn(executorService()); &#125; return isRunning; &#125; 调用了asyncCall.executeOn方法 1234567891011121314151617void executeOn(ExecutorService executorService) &#123; assert (!Thread.holdsLock(client.dispatcher())); boolean success = false; try &#123; executorService.execute(this); success = true; &#125; catch (RejectedExecutionException e) &#123; InterruptedIOException ioException = new InterruptedIOException(&quot;executor rejected&quot;); ioException.initCause(e); eventListener.callFailed(RealCall.this, ioException); responseCallback.onFailure(RealCall.this, ioException); &#125; finally &#123; if (!success) &#123; client.dispatcher().finished(this); // This call is no longer running! &#125; &#125; &#125; 最后还是调用了execute方法，接下来就跟同步流程一样，调用了getResponseWithInterceptorChain方法。 总结 整个流程看下来，有点体会 。看源码不能心急，需要一步一步的看下去。网上有很多相关的博客，可以先跟博客的思路走一遍，然后自己再把流程看一遍，最后自己画一个流程图。做完这三步，基本上是掌握了，面试的时候也可以理直气壮的跟面试官说OkHttp的源码流程了。]]></content>
      <categories>
        <category>OkHttp系列</category>
      </categories>
      <tags>
        <tag>OkHttp源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter系列之HelloFlutter]]></title>
    <url>%2F2018%2F12%2F21%2FFlutter%E7%B3%BB%E5%88%97%E4%B9%8BHelloFlutter%2F</url>
    <content type="text"><![CDATA[前言在上一篇文章中，我们在Windows环境下搭建了Flutter的开发环境，并且通过AS成功运行了Flutter的示例Demo。今天我们来动手实现自己的第一个Flutter项目，HelloFlutter。 新建HelloFlutter通过AS，我们可以新建一个Flutter项目，如下图 接下来我们填写项目的基本信息就好了，然后等待项目新建完成后，我们会看到AS已经为我们生成了默认的代码。因为我们需要学习如何创建属于自己的Flutter项目，所以将main.dart文件中的所有代码删除。 新建main函数现在我们首先创建一个main函数，主要代码是运行在main函数中的，如下图 1234//第一种写法void main ()&#123; runApp(MyApp());&#125; 12//第二种以下写法，仅限于函数体只有一行代码void main() =&gt; runApp(MyApp()); 在代码中我们可以看出main函数有俩种写法，第一种是比较常规的写法，而第二种写法仅限于函数体中只有一行代码，否则不可以。 MyApp通过对Flutter了解，我们可以知道在Flutter中，有许多Widget。Widget主要分为俩种，一种是StatelessWidget，表示不可变状态窗口组件，也就是说它是不可以改变的，比如文字。另外一种是StatefulWidget，表示可变状态窗口组件，比如进度条。那么我们需要在项目中显示文字HelloFlutter，就需要StatelessWidget，然后我们创建MyAPP，并继承StatelessWidget。 1234567class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return null; &#125;&#125; 当我们继承了StatelessWidget时，AS会提示我们需要创建build方法。从上面代码中可以看出build方法默认返回null。然后我们来实现一个material风格的app，代码如下 12345678910111213141516171819@override Widget build(BuildContext context) &#123; // TODO: implement build return MaterialApp( //表示最近列表中APP名字 title: (&apos;Hello Flutter Demo&apos;), home: Scaffold( //表示APP标题 appBar: AppBar( title: Text(&apos;Flutter Demo&apos;), ), //Center表示居中 body: Center( //表示Text child: Text(&apos;Hello Flutter&apos;), ), ), ); &#125; 通过代码中的注释，我们大概可以看懂上面的属性代表什么意思。然后我们运行APP，就可以在设备上看到Hello Flutter界面了。 总结建议同学们多写几次Hello Flutter项目，多了解下上面出现过得属性。]]></content>
      <categories>
        <category>Flutter系列</category>
      </categories>
      <tags>
        <tag>HelloFlutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter之Windows开发环境搭建]]></title>
    <url>%2F2018%2F12%2F20%2FFlutter%E7%B3%BB%E5%88%97%E4%B9%8BWindows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言RN出现时，没有去详细的学习。现在Flutter正式版出来了，好好的研究下。本文主要介绍在Windows环境下，搭建Flutter的各种坑。 开发环境 Windows 10 Android Studio 3.2.1 一加 5T 下载Flutter源码主要参照Flutter官方文档，下载Flutter源码，如下： 1git clone -b beta https://github.com/flutter/flutter.git 配置环境变量下载成功后，为了以后方便使用，将Flutter根目录下bin路径添加到PATH环境变量中。 国内镜像设置由于有些同学们不能科学上网的原因，我们需要设置国内镜像。根据官方文档推荐，需要添加PUB_HOSTED_URL和FLUTTER_STORAGE_BASE_URL两个环境变量，具体值如下 12PUB_HOSTED_URL=https://pub.flutter-io.cnFLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 运行Flutter安装程序在Flutter根目录中，同学们找到flutter_console.bat。然后双击运行，就会出现Flutter控制台，然后我们执行flutter doctor，等待一段时间后，Flutter会出现安装结果。 AS中安装Flutter插件 安装Flutter插件后会自动安装Dart插件，然后设置Flutter和Dart二者SDK路径，如下 运行Flutter Demo经过上面的安装步骤，想必同学们已经安装成功了。那么接下来我们就是要运行Flutter Demo了，如下 在Flutter根目录的examples中有几个Flutter Demo，我们在flutter_gallery根目录中运行“flutter run”命令，就可以运行在手机中了。 或者通过Android Studio打开flutter_gallery ，然后直接运行程序。 问题Waiting for another flutter command to release the startup lock…解决方法如下： 打开任务管理器，结束所有的dart.exe 如果开启了代理，关闭代理 重启AS Unable to find git in your PATH出现这个错误，需要我们正确的设置Git环境变量。我们将git的bin路径添加到环境变量中。 总结在Windows环境下配置Flutter还是有比较多坑的，遇到问题一个一个的解决。能够科学上网的同学尽量在Google上搜索问题的解决方法，可以解决大部分问题。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FragmentPagerAdapter和FragmentStatePagerAdapter区别]]></title>
    <url>%2F2018%2F12%2F09%2FFragmentPagerAdapter%E5%92%8CFragmentStatePagerAdapter%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言“变强，从现在开始变为我心中的执念。” StrongPlan计划，也就是变强计划，从现在开始。经历过裁员风波，认识到了自己严重的不足。有句老话说得好，打铁还需自身硬！ FragmentPagerAdapter首先我们来看一下FragmentPagerAdapter的destroyItem方法源码 1234567public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123; if (this.mCurTransaction == null) &#123; this.mCurTransaction = this.mFragmentManager.beginTransaction(); &#125; this.mCurTransaction.detach((Fragment)object); &#125; 方法最后调用了detach方法，将Fragment的View销毁，而Fragment对象还存在。FragmentPagerAdapter会将每一个生成的Fragment保存在内存中，所以只适用于页面较少的情况。如果页面比较多，内存占用较大，用户体验会不好。 FragmentStatePagerAdapter我们还是看一下FragmentStatePagerAdapter的destroyItem方法，看一是如何处理的。 1234567891011121314public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123; Fragment fragment = (Fragment)object; if (this.mCurTransaction == null) &#123; this.mCurTransaction = this.mFragmentManager.beginTransaction(); &#125; while(this.mSavedState.size() &lt;= position) &#123; this.mSavedState.add((Object)null); &#125; this.mSavedState.set(position, fragment.isAdded() ? this.mFragmentManager.saveFragmentInstanceState(fragment) : null); this.mFragments.set(position, (Object)null); this.mCurTransaction.remove(fragment); &#125; 可以看出跟FragmentPagerAdapter不同的是，最后调用了remove方法。会将Fragment删除并释放资源，也就是说保留当前Fragment，当Fragment离开后，就会被消除，然后释放资源。 总结通过分析，可以得知FragmentPagerAdapter适合页面较少的情况。FragmentStatePagerAdapter适合页面较多，不会占据大量的内存。]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Fragment</tag>
      </tags>
  </entry>
</search>
